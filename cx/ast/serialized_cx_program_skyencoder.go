// Code generated by github.com/skycoin/skyencoder. DO NOT EDIT.

package ast

import (
	"errors"
	"math"

	"github.com/skycoin/skycoin/src/cipher/encoder"
)

// EncodeSizeSerializedCXProgram computes the size of an encoded object of type SerializedCXProgram
func EncodeSizeSerializedCXProgram(obj *SerializedCXProgram) uint64 {
	i0 := uint64(0)

	// obj.Index.ProgramOffset
	i0 += 8

	// obj.Index.CallsOffset
	i0 += 8

	// obj.Index.PackagesOffset
	i0 += 8

	// obj.Index.StructsOffset
	i0 += 8

	// obj.Index.FunctionsOffset
	i0 += 8

	// obj.Index.ExpressionsOffset
	i0 += 8

	// obj.Index.ArgumentsOffset
	i0 += 8

	// obj.Index.IntegersOffset
	i0 += 8

	// obj.Index.StringsOffset
	i0 += 8

	// obj.Index.MemoryOffset
	i0 += 8

	// obj.Program.PackagesOffset
	i0 += 8

	// obj.Program.PackagesSize
	i0 += 8

	// obj.Program.CurrentPackageOffset
	i0 += 8

	// obj.Program.InputsOffset
	i0 += 8

	// obj.Program.InputsSize
	i0 += 8

	// obj.Program.OutputsOffset
	i0 += 8

	// obj.Program.OutputsSize
	i0 += 8

	// obj.Program.CallStackOffset
	i0 += 8

	// obj.Program.CallStackSize
	i0 += 8

	// obj.Program.CallCounter
	i0 += 8

	// obj.Program.MemoryOffset
	i0 += 8

	// obj.Program.MemorySize
	i0 += 8

	// obj.Program.StackPointer
	i0 += 8

	// obj.Program.StackSize
	i0 += 8

	// obj.Program.DataSegmentSize
	i0 += 8

	// obj.Program.DataSegmentStartsAt
	i0 += 8

	// obj.Program.HeapPointer
	i0 += 8

	// obj.Program.HeapStartsAt
	i0 += 8

	// obj.Program.HeapSize
	i0 += 8

	// obj.Program.Terminated
	i0 += 8

	// obj.Program.VersionOffset
	i0 += 8

	// obj.Program.VersionSize
	i0 += 8

	// obj.Packages
	i0 += 4
	{
		i1 := uint64(0)

		// x1.NameOffset
		i1 += 8

		// x1.NameSize
		i1 += 8

		// x1.ImportsOffset
		i1 += 8

		// x1.ImportsSize
		i1 += 8

		// x1.StructsOffset
		i1 += 8

		// x1.StructsSize
		i1 += 8

		// x1.GlobalsOffset
		i1 += 8

		// x1.GlobalsSize
		i1 += 8

		// x1.FunctionsOffset
		i1 += 8

		// x1.FunctionsSize
		i1 += 8

		// x1.CurrentFunctionOffset
		i1 += 8

		// x1.CurrentStructOffset
		i1 += 8

		i0 += uint64(len(obj.Packages)) * i1
	}

	// obj.PackagesMap
	i0 += 4
	for k1, _ := range obj.PackagesMap {
		i1 := uint64(0)

		// k1
		i1 += 4 + uint64(len(k1))

		// v1
		i1 += 8

		i0 += i1
	}

	// obj.Structs
	i0 += 4
	{
		i1 := uint64(0)

		// x1.NameOffset
		i1 += 8

		// x1.NameSize
		i1 += 8

		// x1.FieldsOffset
		i1 += 8

		// x1.FieldsSize
		i1 += 8

		// x1.Size
		i1 += 8

		// x1.PackageOffset
		i1 += 8

		i0 += uint64(len(obj.Structs)) * i1
	}

	// obj.StructsMap
	i0 += 4
	for k1, _ := range obj.StructsMap {
		i1 := uint64(0)

		// k1
		i1 += 4 + uint64(len(k1))

		// v1
		i1 += 8

		i0 += i1
	}

	// obj.Functions
	i0 += 4
	{
		i1 := uint64(0)

		// x1.NameOffset
		i1 += 8

		// x1.NameSize
		i1 += 8

		// x1.InputsOffset
		i1 += 8

		// x1.InputsSize
		i1 += 8

		// x1.OutputsOffset
		i1 += 8

		// x1.OutputsSize
		i1 += 8

		// x1.ExpressionsOffset
		i1 += 8

		// x1.ExpressionsSize
		i1 += 8

		// x1.Size
		i1 += 8

		// x1.Length
		i1 += 8

		// x1.ListOfPointersOffset
		i1 += 8

		// x1.ListOfPointersSize
		i1 += 8

		// x1.CurrentExpressionOffset
		i1 += 8

		// x1.PackageOffset
		i1 += 8

		i0 += uint64(len(obj.Functions)) * i1
	}

	// obj.FunctionsMap
	i0 += 4
	for k1, _ := range obj.FunctionsMap {
		i1 := uint64(0)

		// k1
		i1 += 4 + uint64(len(k1))

		// v1
		i1 += 8

		i0 += i1
	}

	// obj.Expressions
	i0 += 4
	{
		i1 := uint64(0)

		// x1.OperatorOffset
		i1 += 8

		// x1.IsNative
		i1 += 8

		// x1.OpCode
		i1 += 8

		// x1.InputsOffset
		i1 += 8

		// x1.InputsSize
		i1 += 8

		// x1.OutputsOffset
		i1 += 8

		// x1.OutputsSize
		i1 += 8

		// x1.LabelOffset
		i1 += 8

		// x1.LabelSize
		i1 += 8

		// x1.ThenLines
		i1 += 8

		// x1.ElseLines
		i1 += 8

		// x1.ExpressionType
		i1 += 8

		// x1.FunctionOffset
		i1 += 8

		// x1.PackageOffset
		i1 += 8

		i0 += uint64(len(obj.Expressions)) * i1
	}

	// obj.Arguments
	i0 += 4
	{
		i1 := uint64(0)

		// x1.NameOffset
		i1 += 8

		// x1.NameSize
		i1 += 8

		// x1.Type
		i1 += 8

		// x1.StructTypeOffset
		i1 += 8

		// x1.Size
		i1 += 8

		// x1.TotalSize
		i1 += 8

		// x1.Offset
		i1 += 8

		// x1.IndirectionLevels
		i1 += 8

		// x1.DereferenceLevels
		i1 += 8

		// x1.DeclarationSpecifiersOffset
		i1 += 8

		// x1.DeclarationSpecifiersSize
		i1 += 8

		// x1.IsSlice
		i1 += 8

		// x1.IsPointer
		i1 += 8

		// x1.IsReference
		i1 += 8

		// x1.IsStruct
		i1 += 8

		// x1.IsRest
		i1 += 8

		// x1.IsLocalDeclaration
		i1 += 8

		// x1.IsShortDeclaration
		i1 += 8

		// x1.PreviouslyDeclared
		i1 += 8

		// x1.PassBy
		i1 += 8

		// x1.DoesEscape
		i1 += 8

		// x1.LengthsOffset
		i1 += 8

		// x1.LengthsSize
		i1 += 8

		// x1.IndexesOffset
		i1 += 8

		// x1.IndexesSize
		i1 += 8

		// x1.FieldsOffset
		i1 += 8

		// x1.FieldsSize
		i1 += 8

		// x1.InputsOffset
		i1 += 8

		// x1.InputsSize
		i1 += 8

		// x1.OutputsOffset
		i1 += 8

		// x1.OutputsSize
		i1 += 8

		// x1.PackageOffset
		i1 += 8

		i0 += uint64(len(obj.Arguments)) * i1
	}

	// obj.Calls
	i0 += 4
	{
		i1 := uint64(0)

		// x1.OperatorOffset
		i1 += 8

		// x1.Line
		i1 += 8

		// x1.FramePointer
		i1 += 8

		i0 += uint64(len(obj.Calls)) * i1
	}

	// obj.Strings
	i0 += 4 + uint64(len(obj.Strings))

	// obj.StringsMap
	i0 += 4
	for k1, _ := range obj.StringsMap {
		i1 := uint64(0)

		// k1
		i1 += 4 + uint64(len(k1))

		// v1
		i1 += 8

		i0 += i1
	}

	// obj.Integers
	i0 += 4
	{
		i1 := uint64(0)

		// x1
		i1 += 8

		i0 += uint64(len(obj.Integers)) * i1
	}

	// obj.Memory
	i0 += 4 + uint64(len(obj.Memory))

	return i0
}

// EncodeSerializedCXProgram encodes an object of type SerializedCXProgram to a buffer allocated to the exact size
// required to encode the object.
func EncodeSerializedCXProgram(obj *SerializedCXProgram) ([]byte, error) {
	n := EncodeSizeSerializedCXProgram(obj)
	buf := make([]byte, n)

	if err := EncodeSerializedCXProgramToBuffer(buf, obj); err != nil {
		return nil, err
	}

	return buf, nil
}

// EncodeSerializedCXProgramToBuffer encodes an object of type SerializedCXProgram to a []byte buffer.
// The buffer must be large enough to encode the object, otherwise an error is returned.
func EncodeSerializedCXProgramToBuffer(buf []byte, obj *SerializedCXProgram) error {
	if uint64(len(buf)) < EncodeSizeSerializedCXProgram(obj) {
		return encoder.ErrBufferUnderflow
	}

	e := &encoder.Encoder{
		Buffer: buf[:],
	}

	// obj.Index.ProgramOffset
	e.Int64(obj.Index.ProgramOffset)

	// obj.Index.CallsOffset
	e.Int64(obj.Index.CallsOffset)

	// obj.Index.PackagesOffset
	e.Int64(obj.Index.PackagesOffset)

	// obj.Index.StructsOffset
	e.Int64(obj.Index.StructsOffset)

	// obj.Index.FunctionsOffset
	e.Int64(obj.Index.FunctionsOffset)

	// obj.Index.ExpressionsOffset
	e.Int64(obj.Index.ExpressionsOffset)

	// obj.Index.ArgumentsOffset
	e.Int64(obj.Index.ArgumentsOffset)

	// obj.Index.IntegersOffset
	e.Int64(obj.Index.IntegersOffset)

	// obj.Index.StringsOffset
	e.Int64(obj.Index.StringsOffset)

	// obj.Index.MemoryOffset
	e.Int64(obj.Index.MemoryOffset)

	// obj.Program.PackagesOffset
	e.Int64(obj.Program.PackagesOffset)

	// obj.Program.PackagesSize
	e.Int64(obj.Program.PackagesSize)

	// obj.Program.CurrentPackageOffset
	e.Int64(obj.Program.CurrentPackageOffset)

	// obj.Program.InputsOffset
	e.Int64(obj.Program.InputsOffset)

	// obj.Program.InputsSize
	e.Int64(obj.Program.InputsSize)

	// obj.Program.OutputsOffset
	e.Int64(obj.Program.OutputsOffset)

	// obj.Program.OutputsSize
	e.Int64(obj.Program.OutputsSize)

	// obj.Program.CallStackOffset
	e.Int64(obj.Program.CallStackOffset)

	// obj.Program.CallStackSize
	e.Int64(obj.Program.CallStackSize)

	// obj.Program.CallCounter
	e.Int64(obj.Program.CallCounter)

	// obj.Program.MemoryOffset
	e.Int64(obj.Program.MemoryOffset)

	// obj.Program.MemorySize
	e.Int64(obj.Program.MemorySize)

	// obj.Program.StackPointer
	e.Int64(obj.Program.StackPointer)

	// obj.Program.StackSize
	e.Int64(obj.Program.StackSize)

	// obj.Program.DataSegmentSize
	e.Int64(obj.Program.DataSegmentSize)

	// obj.Program.DataSegmentStartsAt
	e.Int64(obj.Program.DataSegmentStartsAt)

	// obj.Program.HeapPointer
	e.Int64(obj.Program.HeapPointer)

	// obj.Program.HeapStartsAt
	e.Int64(obj.Program.HeapStartsAt)

	// obj.Program.HeapSize
	e.Int64(obj.Program.HeapSize)

	// obj.Program.Terminated
	e.Int64(obj.Program.Terminated)

	// obj.Program.VersionOffset
	e.Int64(obj.Program.VersionOffset)

	// obj.Program.VersionSize
	e.Int64(obj.Program.VersionSize)

	// obj.Packages length check
	if uint64(len(obj.Packages)) > math.MaxUint32 {
		return errors.New("obj.Packages length exceeds math.MaxUint32")
	}

	// obj.Packages length
	e.Uint32(uint32(len(obj.Packages)))

	// obj.Packages
	for _, x := range obj.Packages {

		// x.NameOffset
		e.Int64(x.NameOffset)

		// x.NameSize
		e.Int64(x.NameSize)

		// x.ImportsOffset
		e.Int64(x.ImportsOffset)

		// x.ImportsSize
		e.Int64(x.ImportsSize)

		// x.StructsOffset
		e.Int64(x.StructsOffset)

		// x.StructsSize
		e.Int64(x.StructsSize)

		// x.GlobalsOffset
		e.Int64(x.GlobalsOffset)

		// x.GlobalsSize
		e.Int64(x.GlobalsSize)

		// x.FunctionsOffset
		e.Int64(x.FunctionsOffset)

		// x.FunctionsSize
		e.Int64(x.FunctionsSize)

		// x.CurrentFunctionOffset
		e.Int64(x.CurrentFunctionOffset)

		// x.CurrentStructOffset
		e.Int64(x.CurrentStructOffset)

	}

	// obj.PackagesMap

	// obj.PackagesMap length check
	if uint64(len(obj.PackagesMap)) > math.MaxUint32 {
		return errors.New("obj.PackagesMap length exceeds math.MaxUint32")
	}

	// obj.PackagesMap length
	e.Uint32(uint32(len(obj.PackagesMap)))

	for k, v := range obj.PackagesMap {

		// k length check
		if uint64(len(k)) > math.MaxUint32 {
			return errors.New("k length exceeds math.MaxUint32")
		}

		// k
		e.ByteSlice([]byte(k))

		// v
		e.Int64(v)

	}

	// obj.Structs length check
	if uint64(len(obj.Structs)) > math.MaxUint32 {
		return errors.New("obj.Structs length exceeds math.MaxUint32")
	}

	// obj.Structs length
	e.Uint32(uint32(len(obj.Structs)))

	// obj.Structs
	for _, x := range obj.Structs {

		// x.NameOffset
		e.Int64(x.NameOffset)

		// x.NameSize
		e.Int64(x.NameSize)

		// x.FieldsOffset
		e.Int64(x.FieldsOffset)

		// x.FieldsSize
		e.Int64(x.FieldsSize)

		// x.Size
		e.Int64(x.Size)

		// x.PackageOffset
		e.Int64(x.PackageOffset)

	}

	// obj.StructsMap

	// obj.StructsMap length check
	if uint64(len(obj.StructsMap)) > math.MaxUint32 {
		return errors.New("obj.StructsMap length exceeds math.MaxUint32")
	}

	// obj.StructsMap length
	e.Uint32(uint32(len(obj.StructsMap)))

	for k, v := range obj.StructsMap {

		// k length check
		if uint64(len(k)) > math.MaxUint32 {
			return errors.New("k length exceeds math.MaxUint32")
		}

		// k
		e.ByteSlice([]byte(k))

		// v
		e.Int64(v)

	}

	// obj.Functions length check
	if uint64(len(obj.Functions)) > math.MaxUint32 {
		return errors.New("obj.Functions length exceeds math.MaxUint32")
	}

	// obj.Functions length
	e.Uint32(uint32(len(obj.Functions)))

	// obj.Functions
	for _, x := range obj.Functions {

		// x.NameOffset
		e.Int64(x.NameOffset)

		// x.NameSize
		e.Int64(x.NameSize)

		// x.InputsOffset
		e.Int64(x.InputsOffset)

		// x.InputsSize
		e.Int64(x.InputsSize)

		// x.OutputsOffset
		e.Int64(x.OutputsOffset)

		// x.OutputsSize
		e.Int64(x.OutputsSize)

		// x.ExpressionsOffset
		e.Int64(x.ExpressionsOffset)

		// x.ExpressionsSize
		e.Int64(x.ExpressionsSize)

		// x.Size
		e.Int64(x.Size)

		// x.Length
		e.Int64(x.Length)

		// x.ListOfPointersOffset
		e.Int64(x.ListOfPointersOffset)

		// x.ListOfPointersSize
		e.Int64(x.ListOfPointersSize)

		// x.CurrentExpressionOffset
		e.Int64(x.CurrentExpressionOffset)

		// x.PackageOffset
		e.Int64(x.PackageOffset)

	}

	// obj.FunctionsMap

	// obj.FunctionsMap length check
	if uint64(len(obj.FunctionsMap)) > math.MaxUint32 {
		return errors.New("obj.FunctionsMap length exceeds math.MaxUint32")
	}

	// obj.FunctionsMap length
	e.Uint32(uint32(len(obj.FunctionsMap)))

	for k, v := range obj.FunctionsMap {

		// k length check
		if uint64(len(k)) > math.MaxUint32 {
			return errors.New("k length exceeds math.MaxUint32")
		}

		// k
		e.ByteSlice([]byte(k))

		// v
		e.Int64(v)

	}

	// obj.Expressions length check
	if uint64(len(obj.Expressions)) > math.MaxUint32 {
		return errors.New("obj.Expressions length exceeds math.MaxUint32")
	}

	// obj.Expressions length
	e.Uint32(uint32(len(obj.Expressions)))

	// obj.Expressions
	for _, x := range obj.Expressions {

		// x.OperatorOffset
		e.Int64(x.OperatorOffset)

		// x.IsNative
		e.Int64(x.IsNative)

		// x.OpCode
		e.Int64(x.OpCode)

		// x.InputsOffset
		e.Int64(x.InputsOffset)

		// x.InputsSize
		e.Int64(x.InputsSize)

		// x.OutputsOffset
		e.Int64(x.OutputsOffset)

		// x.OutputsSize
		e.Int64(x.OutputsSize)

		// x.LabelOffset
		e.Int64(x.LabelOffset)

		// x.LabelSize
		e.Int64(x.LabelSize)

		// x.ThenLines
		e.Int64(x.ThenLines)

		// x.ElseLines
		e.Int64(x.ElseLines)

		// x.ExpressionType
		e.Int64(x.ExpressionType)

		// x.FunctionOffset
		e.Int64(x.FunctionOffset)

		// x.PackageOffset
		e.Int64(x.PackageOffset)

	}

	// obj.Arguments length check
	if uint64(len(obj.Arguments)) > math.MaxUint32 {
		return errors.New("obj.Arguments length exceeds math.MaxUint32")
	}

	// obj.Arguments length
	e.Uint32(uint32(len(obj.Arguments)))

	// obj.Arguments
	for _, x := range obj.Arguments {

		// x.NameOffset
		e.Int64(x.NameOffset)

		// x.NameSize
		e.Int64(x.NameSize)

		// x.Type
		e.Int64(x.Type)

		// x.StructTypeOffset
		e.Int64(x.StructTypeOffset)

		// x.Size
		e.Int64(x.Size)

		// x.TotalSize
		e.Int64(x.TotalSize)

		// x.Offset
		e.Int64(x.Offset)

		// x.IndirectionLevels
		e.Int64(x.IndirectionLevels)

		// x.DereferenceLevels
		e.Int64(x.DereferenceLevels)

		// x.DeclarationSpecifiersOffset
		e.Int64(x.DeclarationSpecifiersOffset)

		// x.DeclarationSpecifiersSize
		e.Int64(x.DeclarationSpecifiersSize)

		// x.IsSlice
		e.Int64(x.IsSlice)

		// x.IsPointer
		e.Int64(x.IsPointer)

		// x.IsReference
		e.Int64(x.IsReference)

		// x.IsStruct
		e.Int64(x.IsStruct)

		// x.IsRest
		e.Int64(x.IsRest)

		// x.IsLocalDeclaration
		e.Int64(x.IsLocalDeclaration)

		// x.IsShortDeclaration
		e.Int64(x.IsShortDeclaration)

		// x.PreviouslyDeclared
		e.Int64(x.PreviouslyDeclared)

		// x.PassBy
		e.Int64(x.PassBy)

		// x.DoesEscape
		e.Int64(x.DoesEscape)

		// x.LengthsOffset
		e.Int64(x.LengthsOffset)

		// x.LengthsSize
		e.Int64(x.LengthsSize)

		// x.IndexesOffset
		e.Int64(x.IndexesOffset)

		// x.IndexesSize
		e.Int64(x.IndexesSize)

		// x.FieldsOffset
		e.Int64(x.FieldsOffset)

		// x.FieldsSize
		e.Int64(x.FieldsSize)

		// x.InputsOffset
		e.Int64(x.InputsOffset)

		// x.InputsSize
		e.Int64(x.InputsSize)

		// x.OutputsOffset
		e.Int64(x.OutputsOffset)

		// x.OutputsSize
		e.Int64(x.OutputsSize)

		// x.PackageOffset
		e.Int64(x.PackageOffset)

	}

	// obj.Calls length check
	if uint64(len(obj.Calls)) > math.MaxUint32 {
		return errors.New("obj.Calls length exceeds math.MaxUint32")
	}

	// obj.Calls length
	e.Uint32(uint32(len(obj.Calls)))

	// obj.Calls
	for _, x := range obj.Calls {

		// x.OperatorOffset
		e.Int64(x.OperatorOffset)

		// x.Line
		e.Int64(x.Line)

		// x.FramePointer
		e.Int64(x.FramePointer)

	}

	// obj.Strings length check
	if uint64(len(obj.Strings)) > math.MaxUint32 {
		return errors.New("obj.Strings length exceeds math.MaxUint32")
	}

	// obj.Strings length
	e.Uint32(uint32(len(obj.Strings)))

	// obj.Strings copy
	e.CopyBytes(obj.Strings)

	// obj.StringsMap

	// obj.StringsMap length check
	if uint64(len(obj.StringsMap)) > math.MaxUint32 {
		return errors.New("obj.StringsMap length exceeds math.MaxUint32")
	}

	// obj.StringsMap length
	e.Uint32(uint32(len(obj.StringsMap)))

	for k, v := range obj.StringsMap {

		// k length check
		if uint64(len(k)) > math.MaxUint32 {
			return errors.New("k length exceeds math.MaxUint32")
		}

		// k
		e.ByteSlice([]byte(k))

		// v
		e.Int64(v)

	}

	// obj.Integers length check
	if uint64(len(obj.Integers)) > math.MaxUint32 {
		return errors.New("obj.Integers length exceeds math.MaxUint32")
	}

	// obj.Integers length
	e.Uint32(uint32(len(obj.Integers)))

	// obj.Integers
	for _, x := range obj.Integers {

		// x
		e.Int64(x)

	}

	// obj.Memory length check
	if uint64(len(obj.Memory)) > math.MaxUint32 {
		return errors.New("obj.Memory length exceeds math.MaxUint32")
	}

	// obj.Memory length
	e.Uint32(uint32(len(obj.Memory)))

	// obj.Memory copy
	e.CopyBytes(obj.Memory)

	return nil
}

// DecodeSerializedCXProgram decodes an object of type SerializedCXProgram from a buffer.
// Returns the number of bytes used from the buffer to decode the object.
// If the buffer not long enough to decode the object, returns encoder.ErrBufferUnderflow.
func DecodeSerializedCXProgram(buf []byte, obj *SerializedCXProgram) (uint64, error) {
	d := &encoder.Decoder{
		Buffer: buf[:],
	}

	{
		// obj.Index.ProgramOffset
		i, err := d.Int64()
		if err != nil {
			return 0, err
		}
		obj.Index.ProgramOffset = i
	}

	{
		// obj.Index.CallsOffset
		i, err := d.Int64()
		if err != nil {
			return 0, err
		}
		obj.Index.CallsOffset = i
	}

	{
		// obj.Index.PackagesOffset
		i, err := d.Int64()
		if err != nil {
			return 0, err
		}
		obj.Index.PackagesOffset = i
	}

	{
		// obj.Index.StructsOffset
		i, err := d.Int64()
		if err != nil {
			return 0, err
		}
		obj.Index.StructsOffset = i
	}

	{
		// obj.Index.FunctionsOffset
		i, err := d.Int64()
		if err != nil {
			return 0, err
		}
		obj.Index.FunctionsOffset = i
	}

	{
		// obj.Index.ExpressionsOffset
		i, err := d.Int64()
		if err != nil {
			return 0, err
		}
		obj.Index.ExpressionsOffset = i
	}

	{
		// obj.Index.ArgumentsOffset
		i, err := d.Int64()
		if err != nil {
			return 0, err
		}
		obj.Index.ArgumentsOffset = i
	}

	{
		// obj.Index.IntegersOffset
		i, err := d.Int64()
		if err != nil {
			return 0, err
		}
		obj.Index.IntegersOffset = i
	}

	{
		// obj.Index.StringsOffset
		i, err := d.Int64()
		if err != nil {
			return 0, err
		}
		obj.Index.StringsOffset = i
	}

	{
		// obj.Index.MemoryOffset
		i, err := d.Int64()
		if err != nil {
			return 0, err
		}
		obj.Index.MemoryOffset = i
	}

	{
		// obj.Program.PackagesOffset
		i, err := d.Int64()
		if err != nil {
			return 0, err
		}
		obj.Program.PackagesOffset = i
	}

	{
		// obj.Program.PackagesSize
		i, err := d.Int64()
		if err != nil {
			return 0, err
		}
		obj.Program.PackagesSize = i
	}

	{
		// obj.Program.CurrentPackageOffset
		i, err := d.Int64()
		if err != nil {
			return 0, err
		}
		obj.Program.CurrentPackageOffset = i
	}

	{
		// obj.Program.InputsOffset
		i, err := d.Int64()
		if err != nil {
			return 0, err
		}
		obj.Program.InputsOffset = i
	}

	{
		// obj.Program.InputsSize
		i, err := d.Int64()
		if err != nil {
			return 0, err
		}
		obj.Program.InputsSize = i
	}

	{
		// obj.Program.OutputsOffset
		i, err := d.Int64()
		if err != nil {
			return 0, err
		}
		obj.Program.OutputsOffset = i
	}

	{
		// obj.Program.OutputsSize
		i, err := d.Int64()
		if err != nil {
			return 0, err
		}
		obj.Program.OutputsSize = i
	}

	{
		// obj.Program.CallStackOffset
		i, err := d.Int64()
		if err != nil {
			return 0, err
		}
		obj.Program.CallStackOffset = i
	}

	{
		// obj.Program.CallStackSize
		i, err := d.Int64()
		if err != nil {
			return 0, err
		}
		obj.Program.CallStackSize = i
	}

	{
		// obj.Program.CallCounter
		i, err := d.Int64()
		if err != nil {
			return 0, err
		}
		obj.Program.CallCounter = i
	}

	{
		// obj.Program.MemoryOffset
		i, err := d.Int64()
		if err != nil {
			return 0, err
		}
		obj.Program.MemoryOffset = i
	}

	{
		// obj.Program.MemorySize
		i, err := d.Int64()
		if err != nil {
			return 0, err
		}
		obj.Program.MemorySize = i
	}

	{
		// obj.Program.StackPointer
		i, err := d.Int64()
		if err != nil {
			return 0, err
		}
		obj.Program.StackPointer = i
	}

	{
		// obj.Program.StackSize
		i, err := d.Int64()
		if err != nil {
			return 0, err
		}
		obj.Program.StackSize = i
	}

	{
		// obj.Program.DataSegmentSize
		i, err := d.Int64()
		if err != nil {
			return 0, err
		}
		obj.Program.DataSegmentSize = i
	}

	{
		// obj.Program.DataSegmentStartsAt
		i, err := d.Int64()
		if err != nil {
			return 0, err
		}
		obj.Program.DataSegmentStartsAt = i
	}

	{
		// obj.Program.HeapPointer
		i, err := d.Int64()
		if err != nil {
			return 0, err
		}
		obj.Program.HeapPointer = i
	}

	{
		// obj.Program.HeapStartsAt
		i, err := d.Int64()
		if err != nil {
			return 0, err
		}
		obj.Program.HeapStartsAt = i
	}

	{
		// obj.Program.HeapSize
		i, err := d.Int64()
		if err != nil {
			return 0, err
		}
		obj.Program.HeapSize = i
	}

	{
		// obj.Program.Terminated
		i, err := d.Int64()
		if err != nil {
			return 0, err
		}
		obj.Program.Terminated = i
	}

	{
		// obj.Program.VersionOffset
		i, err := d.Int64()
		if err != nil {
			return 0, err
		}
		obj.Program.VersionOffset = i
	}

	{
		// obj.Program.VersionSize
		i, err := d.Int64()
		if err != nil {
			return 0, err
		}
		obj.Program.VersionSize = i
	}

	{
		// obj.Packages

		ul, err := d.Uint32()
		if err != nil {
			return 0, err
		}

		length := int(ul)
		if length < 0 || length > len(d.Buffer) {
			return 0, encoder.ErrBufferUnderflow
		}

		if length != 0 {
			obj.Packages = make([]serializedPackage, length)

			for z1 := range obj.Packages {
				{
					// obj.Packages[z1].NameOffset
					i, err := d.Int64()
					if err != nil {
						return 0, err
					}
					obj.Packages[z1].NameOffset = i
				}

				{
					// obj.Packages[z1].NameSize
					i, err := d.Int64()
					if err != nil {
						return 0, err
					}
					obj.Packages[z1].NameSize = i
				}

				{
					// obj.Packages[z1].ImportsOffset
					i, err := d.Int64()
					if err != nil {
						return 0, err
					}
					obj.Packages[z1].ImportsOffset = i
				}

				{
					// obj.Packages[z1].ImportsSize
					i, err := d.Int64()
					if err != nil {
						return 0, err
					}
					obj.Packages[z1].ImportsSize = i
				}

				{
					// obj.Packages[z1].StructsOffset
					i, err := d.Int64()
					if err != nil {
						return 0, err
					}
					obj.Packages[z1].StructsOffset = i
				}

				{
					// obj.Packages[z1].StructsSize
					i, err := d.Int64()
					if err != nil {
						return 0, err
					}
					obj.Packages[z1].StructsSize = i
				}

				{
					// obj.Packages[z1].GlobalsOffset
					i, err := d.Int64()
					if err != nil {
						return 0, err
					}
					obj.Packages[z1].GlobalsOffset = i
				}

				{
					// obj.Packages[z1].GlobalsSize
					i, err := d.Int64()
					if err != nil {
						return 0, err
					}
					obj.Packages[z1].GlobalsSize = i
				}

				{
					// obj.Packages[z1].FunctionsOffset
					i, err := d.Int64()
					if err != nil {
						return 0, err
					}
					obj.Packages[z1].FunctionsOffset = i
				}

				{
					// obj.Packages[z1].FunctionsSize
					i, err := d.Int64()
					if err != nil {
						return 0, err
					}
					obj.Packages[z1].FunctionsSize = i
				}

				{
					// obj.Packages[z1].CurrentFunctionOffset
					i, err := d.Int64()
					if err != nil {
						return 0, err
					}
					obj.Packages[z1].CurrentFunctionOffset = i
				}

				{
					// obj.Packages[z1].CurrentStructOffset
					i, err := d.Int64()
					if err != nil {
						return 0, err
					}
					obj.Packages[z1].CurrentStructOffset = i
				}

			}
		}
	}

	{
		// obj.PackagesMap

		ul, err := d.Uint32()
		if err != nil {
			return 0, err
		}

		length := int(ul)
		if length < 0 || length > len(d.Buffer) {
			return 0, encoder.ErrBufferUnderflow
		}

		if length != 0 {
			obj.PackagesMap = make(map[string]int64)

			for counter := 0; counter < length; counter++ {
				var k1 string

				{
					// k1

					ul, err := d.Uint32()
					if err != nil {
						return 0, err
					}

					length := int(ul)
					if length < 0 || length > len(d.Buffer) {
						return 0, encoder.ErrBufferUnderflow
					}

					k1 = string(d.Buffer[:length])
					d.Buffer = d.Buffer[length:]
				}

				if _, ok := obj.PackagesMap[k1]; ok {
					return 0, encoder.ErrMapDuplicateKeys
				}

				var v1 int64

				{
					// v1
					i, err := d.Int64()
					if err != nil {
						return 0, err
					}
					v1 = i
				}

				obj.PackagesMap[k1] = v1
			}
		}
	}

	{
		// obj.Structs

		ul, err := d.Uint32()
		if err != nil {
			return 0, err
		}

		length := int(ul)
		if length < 0 || length > len(d.Buffer) {
			return 0, encoder.ErrBufferUnderflow
		}

		if length != 0 {
			obj.Structs = make([]serializedStruct, length)

			for z1 := range obj.Structs {
				{
					// obj.Structs[z1].NameOffset
					i, err := d.Int64()
					if err != nil {
						return 0, err
					}
					obj.Structs[z1].NameOffset = i
				}

				{
					// obj.Structs[z1].NameSize
					i, err := d.Int64()
					if err != nil {
						return 0, err
					}
					obj.Structs[z1].NameSize = i
				}

				{
					// obj.Structs[z1].FieldsOffset
					i, err := d.Int64()
					if err != nil {
						return 0, err
					}
					obj.Structs[z1].FieldsOffset = i
				}

				{
					// obj.Structs[z1].FieldsSize
					i, err := d.Int64()
					if err != nil {
						return 0, err
					}
					obj.Structs[z1].FieldsSize = i
				}

				{
					// obj.Structs[z1].Size
					i, err := d.Int64()
					if err != nil {
						return 0, err
					}
					obj.Structs[z1].Size = i
				}

				{
					// obj.Structs[z1].PackageOffset
					i, err := d.Int64()
					if err != nil {
						return 0, err
					}
					obj.Structs[z1].PackageOffset = i
				}

			}
		}
	}

	{
		// obj.StructsMap

		ul, err := d.Uint32()
		if err != nil {
			return 0, err
		}

		length := int(ul)
		if length < 0 || length > len(d.Buffer) {
			return 0, encoder.ErrBufferUnderflow
		}

		if length != 0 {
			obj.StructsMap = make(map[string]int64)

			for counter := 0; counter < length; counter++ {
				var k1 string

				{
					// k1

					ul, err := d.Uint32()
					if err != nil {
						return 0, err
					}

					length := int(ul)
					if length < 0 || length > len(d.Buffer) {
						return 0, encoder.ErrBufferUnderflow
					}

					k1 = string(d.Buffer[:length])
					d.Buffer = d.Buffer[length:]
				}

				if _, ok := obj.StructsMap[k1]; ok {
					return 0, encoder.ErrMapDuplicateKeys
				}

				var v1 int64

				{
					// v1
					i, err := d.Int64()
					if err != nil {
						return 0, err
					}
					v1 = i
				}

				obj.StructsMap[k1] = v1
			}
		}
	}

	{
		// obj.Functions

		ul, err := d.Uint32()
		if err != nil {
			return 0, err
		}

		length := int(ul)
		if length < 0 || length > len(d.Buffer) {
			return 0, encoder.ErrBufferUnderflow
		}

		if length != 0 {
			obj.Functions = make([]serializedFunction, length)

			for z1 := range obj.Functions {
				{
					// obj.Functions[z1].NameOffset
					i, err := d.Int64()
					if err != nil {
						return 0, err
					}
					obj.Functions[z1].NameOffset = i
				}

				{
					// obj.Functions[z1].NameSize
					i, err := d.Int64()
					if err != nil {
						return 0, err
					}
					obj.Functions[z1].NameSize = i
				}

				{
					// obj.Functions[z1].InputsOffset
					i, err := d.Int64()
					if err != nil {
						return 0, err
					}
					obj.Functions[z1].InputsOffset = i
				}

				{
					// obj.Functions[z1].InputsSize
					i, err := d.Int64()
					if err != nil {
						return 0, err
					}
					obj.Functions[z1].InputsSize = i
				}

				{
					// obj.Functions[z1].OutputsOffset
					i, err := d.Int64()
					if err != nil {
						return 0, err
					}
					obj.Functions[z1].OutputsOffset = i
				}

				{
					// obj.Functions[z1].OutputsSize
					i, err := d.Int64()
					if err != nil {
						return 0, err
					}
					obj.Functions[z1].OutputsSize = i
				}

				{
					// obj.Functions[z1].ExpressionsOffset
					i, err := d.Int64()
					if err != nil {
						return 0, err
					}
					obj.Functions[z1].ExpressionsOffset = i
				}

				{
					// obj.Functions[z1].ExpressionsSize
					i, err := d.Int64()
					if err != nil {
						return 0, err
					}
					obj.Functions[z1].ExpressionsSize = i
				}

				{
					// obj.Functions[z1].Size
					i, err := d.Int64()
					if err != nil {
						return 0, err
					}
					obj.Functions[z1].Size = i
				}

				{
					// obj.Functions[z1].Length
					i, err := d.Int64()
					if err != nil {
						return 0, err
					}
					obj.Functions[z1].Length = i
				}

				{
					// obj.Functions[z1].ListOfPointersOffset
					i, err := d.Int64()
					if err != nil {
						return 0, err
					}
					obj.Functions[z1].ListOfPointersOffset = i
				}

				{
					// obj.Functions[z1].ListOfPointersSize
					i, err := d.Int64()
					if err != nil {
						return 0, err
					}
					obj.Functions[z1].ListOfPointersSize = i
				}

				{
					// obj.Functions[z1].CurrentExpressionOffset
					i, err := d.Int64()
					if err != nil {
						return 0, err
					}
					obj.Functions[z1].CurrentExpressionOffset = i
				}

				{
					// obj.Functions[z1].PackageOffset
					i, err := d.Int64()
					if err != nil {
						return 0, err
					}
					obj.Functions[z1].PackageOffset = i
				}

			}
		}
	}

	{
		// obj.FunctionsMap

		ul, err := d.Uint32()
		if err != nil {
			return 0, err
		}

		length := int(ul)
		if length < 0 || length > len(d.Buffer) {
			return 0, encoder.ErrBufferUnderflow
		}

		if length != 0 {
			obj.FunctionsMap = make(map[string]int64)

			for counter := 0; counter < length; counter++ {
				var k1 string

				{
					// k1

					ul, err := d.Uint32()
					if err != nil {
						return 0, err
					}

					length := int(ul)
					if length < 0 || length > len(d.Buffer) {
						return 0, encoder.ErrBufferUnderflow
					}

					k1 = string(d.Buffer[:length])
					d.Buffer = d.Buffer[length:]
				}

				if _, ok := obj.FunctionsMap[k1]; ok {
					return 0, encoder.ErrMapDuplicateKeys
				}

				var v1 int64

				{
					// v1
					i, err := d.Int64()
					if err != nil {
						return 0, err
					}
					v1 = i
				}

				obj.FunctionsMap[k1] = v1
			}
		}
	}

	{
		// obj.Expressions

		ul, err := d.Uint32()
		if err != nil {
			return 0, err
		}

		length := int(ul)
		if length < 0 || length > len(d.Buffer) {
			return 0, encoder.ErrBufferUnderflow
		}

		if length != 0 {
			obj.Expressions = make([]serializedExpression, length)

			for z1 := range obj.Expressions {
				{
					// obj.Expressions[z1].OperatorOffset
					i, err := d.Int64()
					if err != nil {
						return 0, err
					}
					obj.Expressions[z1].OperatorOffset = i
				}

				{
					// obj.Expressions[z1].IsNative
					i, err := d.Int64()
					if err != nil {
						return 0, err
					}
					obj.Expressions[z1].IsNative = i
				}

				{
					// obj.Expressions[z1].OpCode
					i, err := d.Int64()
					if err != nil {
						return 0, err
					}
					obj.Expressions[z1].OpCode = i
				}

				{
					// obj.Expressions[z1].InputsOffset
					i, err := d.Int64()
					if err != nil {
						return 0, err
					}
					obj.Expressions[z1].InputsOffset = i
				}

				{
					// obj.Expressions[z1].InputsSize
					i, err := d.Int64()
					if err != nil {
						return 0, err
					}
					obj.Expressions[z1].InputsSize = i
				}

				{
					// obj.Expressions[z1].OutputsOffset
					i, err := d.Int64()
					if err != nil {
						return 0, err
					}
					obj.Expressions[z1].OutputsOffset = i
				}

				{
					// obj.Expressions[z1].OutputsSize
					i, err := d.Int64()
					if err != nil {
						return 0, err
					}
					obj.Expressions[z1].OutputsSize = i
				}

				{
					// obj.Expressions[z1].LabelOffset
					i, err := d.Int64()
					if err != nil {
						return 0, err
					}
					obj.Expressions[z1].LabelOffset = i
				}

				{
					// obj.Expressions[z1].LabelSize
					i, err := d.Int64()
					if err != nil {
						return 0, err
					}
					obj.Expressions[z1].LabelSize = i
				}

				{
					// obj.Expressions[z1].ThenLines
					i, err := d.Int64()
					if err != nil {
						return 0, err
					}
					obj.Expressions[z1].ThenLines = i
				}

				{
					// obj.Expressions[z1].ElseLines
					i, err := d.Int64()
					if err != nil {
						return 0, err
					}
					obj.Expressions[z1].ElseLines = i
				}

				{
					// obj.Expressions[z1].ExpressionType
					i, err := d.Int64()
					if err != nil {
						return 0, err
					}
					obj.Expressions[z1].ExpressionType = i
				}

				{
					// obj.Expressions[z1].FunctionOffset
					i, err := d.Int64()
					if err != nil {
						return 0, err
					}
					obj.Expressions[z1].FunctionOffset = i
				}

				{
					// obj.Expressions[z1].PackageOffset
					i, err := d.Int64()
					if err != nil {
						return 0, err
					}
					obj.Expressions[z1].PackageOffset = i
				}

			}
		}
	}

	{
		// obj.Arguments

		ul, err := d.Uint32()
		if err != nil {
			return 0, err
		}

		length := int(ul)
		if length < 0 || length > len(d.Buffer) {
			return 0, encoder.ErrBufferUnderflow
		}

		if length != 0 {
			obj.Arguments = make([]serializedArgument, length)

			for z1 := range obj.Arguments {
				{
					// obj.Arguments[z1].NameOffset
					i, err := d.Int64()
					if err != nil {
						return 0, err
					}
					obj.Arguments[z1].NameOffset = i
				}

				{
					// obj.Arguments[z1].NameSize
					i, err := d.Int64()
					if err != nil {
						return 0, err
					}
					obj.Arguments[z1].NameSize = i
				}

				{
					// obj.Arguments[z1].Type
					i, err := d.Int64()
					if err != nil {
						return 0, err
					}
					obj.Arguments[z1].Type = i
				}

				{
					// obj.Arguments[z1].StructTypeOffset
					i, err := d.Int64()
					if err != nil {
						return 0, err
					}
					obj.Arguments[z1].StructTypeOffset = i
				}

				{
					// obj.Arguments[z1].Size
					i, err := d.Int64()
					if err != nil {
						return 0, err
					}
					obj.Arguments[z1].Size = i
				}

				{
					// obj.Arguments[z1].TotalSize
					i, err := d.Int64()
					if err != nil {
						return 0, err
					}
					obj.Arguments[z1].TotalSize = i
				}

				{
					// obj.Arguments[z1].Offset
					i, err := d.Int64()
					if err != nil {
						return 0, err
					}
					obj.Arguments[z1].Offset = i
				}

				{
					// obj.Arguments[z1].IndirectionLevels
					i, err := d.Int64()
					if err != nil {
						return 0, err
					}
					obj.Arguments[z1].IndirectionLevels = i
				}

				{
					// obj.Arguments[z1].DereferenceLevels
					i, err := d.Int64()
					if err != nil {
						return 0, err
					}
					obj.Arguments[z1].DereferenceLevels = i
				}

				{
					// obj.Arguments[z1].DeclarationSpecifiersOffset
					i, err := d.Int64()
					if err != nil {
						return 0, err
					}
					obj.Arguments[z1].DeclarationSpecifiersOffset = i
				}

				{
					// obj.Arguments[z1].DeclarationSpecifiersSize
					i, err := d.Int64()
					if err != nil {
						return 0, err
					}
					obj.Arguments[z1].DeclarationSpecifiersSize = i
				}

				{
					// obj.Arguments[z1].IsSlice
					i, err := d.Int64()
					if err != nil {
						return 0, err
					}
					obj.Arguments[z1].IsSlice = i
				}

				{
					// obj.Arguments[z1].IsPointer
					i, err := d.Int64()
					if err != nil {
						return 0, err
					}
					obj.Arguments[z1].IsPointer = i
				}

				{
					// obj.Arguments[z1].IsReference
					i, err := d.Int64()
					if err != nil {
						return 0, err
					}
					obj.Arguments[z1].IsReference = i
				}

				{
					// obj.Arguments[z1].IsStruct
					i, err := d.Int64()
					if err != nil {
						return 0, err
					}
					obj.Arguments[z1].IsStruct = i
				}

				{
					// obj.Arguments[z1].IsRest
					i, err := d.Int64()
					if err != nil {
						return 0, err
					}
					obj.Arguments[z1].IsRest = i
				}

				{
					// obj.Arguments[z1].IsLocalDeclaration
					i, err := d.Int64()
					if err != nil {
						return 0, err
					}
					obj.Arguments[z1].IsLocalDeclaration = i
				}

				{
					// obj.Arguments[z1].IsShortDeclaration
					i, err := d.Int64()
					if err != nil {
						return 0, err
					}
					obj.Arguments[z1].IsShortDeclaration = i
				}

				{
					// obj.Arguments[z1].PreviouslyDeclared
					i, err := d.Int64()
					if err != nil {
						return 0, err
					}
					obj.Arguments[z1].PreviouslyDeclared = i
				}

				{
					// obj.Arguments[z1].PassBy
					i, err := d.Int64()
					if err != nil {
						return 0, err
					}
					obj.Arguments[z1].PassBy = i
				}

				{
					// obj.Arguments[z1].DoesEscape
					i, err := d.Int64()
					if err != nil {
						return 0, err
					}
					obj.Arguments[z1].DoesEscape = i
				}

				{
					// obj.Arguments[z1].LengthsOffset
					i, err := d.Int64()
					if err != nil {
						return 0, err
					}
					obj.Arguments[z1].LengthsOffset = i
				}

				{
					// obj.Arguments[z1].LengthsSize
					i, err := d.Int64()
					if err != nil {
						return 0, err
					}
					obj.Arguments[z1].LengthsSize = i
				}

				{
					// obj.Arguments[z1].IndexesOffset
					i, err := d.Int64()
					if err != nil {
						return 0, err
					}
					obj.Arguments[z1].IndexesOffset = i
				}

				{
					// obj.Arguments[z1].IndexesSize
					i, err := d.Int64()
					if err != nil {
						return 0, err
					}
					obj.Arguments[z1].IndexesSize = i
				}

				{
					// obj.Arguments[z1].FieldsOffset
					i, err := d.Int64()
					if err != nil {
						return 0, err
					}
					obj.Arguments[z1].FieldsOffset = i
				}

				{
					// obj.Arguments[z1].FieldsSize
					i, err := d.Int64()
					if err != nil {
						return 0, err
					}
					obj.Arguments[z1].FieldsSize = i
				}

				{
					// obj.Arguments[z1].InputsOffset
					i, err := d.Int64()
					if err != nil {
						return 0, err
					}
					obj.Arguments[z1].InputsOffset = i
				}

				{
					// obj.Arguments[z1].InputsSize
					i, err := d.Int64()
					if err != nil {
						return 0, err
					}
					obj.Arguments[z1].InputsSize = i
				}

				{
					// obj.Arguments[z1].OutputsOffset
					i, err := d.Int64()
					if err != nil {
						return 0, err
					}
					obj.Arguments[z1].OutputsOffset = i
				}

				{
					// obj.Arguments[z1].OutputsSize
					i, err := d.Int64()
					if err != nil {
						return 0, err
					}
					obj.Arguments[z1].OutputsSize = i
				}

				{
					// obj.Arguments[z1].PackageOffset
					i, err := d.Int64()
					if err != nil {
						return 0, err
					}
					obj.Arguments[z1].PackageOffset = i
				}

			}
		}
	}

	{
		// obj.Calls

		ul, err := d.Uint32()
		if err != nil {
			return 0, err
		}

		length := int(ul)
		if length < 0 || length > len(d.Buffer) {
			return 0, encoder.ErrBufferUnderflow
		}

		if length != 0 {
			obj.Calls = make([]serializedCall, length)

			for z1 := range obj.Calls {
				{
					// obj.Calls[z1].OperatorOffset
					i, err := d.Int64()
					if err != nil {
						return 0, err
					}
					obj.Calls[z1].OperatorOffset = i
				}

				{
					// obj.Calls[z1].Line
					i, err := d.Int64()
					if err != nil {
						return 0, err
					}
					obj.Calls[z1].Line = i
				}

				{
					// obj.Calls[z1].FramePointer
					i, err := d.Int64()
					if err != nil {
						return 0, err
					}
					obj.Calls[z1].FramePointer = i
				}

			}
		}
	}

	{
		// obj.Strings

		ul, err := d.Uint32()
		if err != nil {
			return 0, err
		}

		length := int(ul)
		if length < 0 || length > len(d.Buffer) {
			return 0, encoder.ErrBufferUnderflow
		}

		if length != 0 {
			obj.Strings = make([]byte, length)

			copy(obj.Strings[:], d.Buffer[:length])
			d.Buffer = d.Buffer[length:]
		}
	}

	{
		// obj.StringsMap

		ul, err := d.Uint32()
		if err != nil {
			return 0, err
		}

		length := int(ul)
		if length < 0 || length > len(d.Buffer) {
			return 0, encoder.ErrBufferUnderflow
		}

		if length != 0 {
			obj.StringsMap = make(map[string]int64)

			for counter := 0; counter < length; counter++ {
				var k1 string

				{
					// k1

					ul, err := d.Uint32()
					if err != nil {
						return 0, err
					}

					length := int(ul)
					if length < 0 || length > len(d.Buffer) {
						return 0, encoder.ErrBufferUnderflow
					}

					k1 = string(d.Buffer[:length])
					d.Buffer = d.Buffer[length:]
				}

				if _, ok := obj.StringsMap[k1]; ok {
					return 0, encoder.ErrMapDuplicateKeys
				}

				var v1 int64

				{
					// v1
					i, err := d.Int64()
					if err != nil {
						return 0, err
					}
					v1 = i
				}

				obj.StringsMap[k1] = v1
			}
		}
	}

	{
		// obj.Integers

		ul, err := d.Uint32()
		if err != nil {
			return 0, err
		}

		length := int(ul)
		if length < 0 || length > len(d.Buffer) {
			return 0, encoder.ErrBufferUnderflow
		}

		if length != 0 {
			obj.Integers = make([]int64, length)

			for z1 := range obj.Integers {
				{
					// obj.Integers[z1]
					i, err := d.Int64()
					if err != nil {
						return 0, err
					}
					obj.Integers[z1] = i
				}

			}
		}
	}

	{
		// obj.Memory

		ul, err := d.Uint32()
		if err != nil {
			return 0, err
		}

		length := int(ul)
		if length < 0 || length > len(d.Buffer) {
			return 0, encoder.ErrBufferUnderflow
		}

		if length != 0 {
			obj.Memory = make([]byte, length)

			copy(obj.Memory[:], d.Buffer[:length])
			d.Buffer = d.Buffer[length:]
		}
	}

	return uint64(len(buf) - len(d.Buffer)), nil
}

// DecodeSerializedCXProgramExact decodes an object of type SerializedCXProgram from a buffer.
// If the buffer not long enough to decode the object, returns encoder.ErrBufferUnderflow.
// If the buffer is longer than required to decode the object, returns encoder.ErrRemainingBytes.
func DecodeSerializedCXProgramExact(buf []byte, obj *SerializedCXProgram) error {
	if n, err := DecodeSerializedCXProgram(buf, obj); err != nil {
		return err
	} else if n != uint64(len(buf)) {
		return encoder.ErrRemainingBytes
	}

	return nil
}
